options
{
  JDK_VERSION = "1.8";
  LOOKAHEAD = 1;
  STATIC = false;
}
PARSER_BEGIN(SpotParser)package epmc.automaton.hoa;

import epmc.util.BitSet;
import epmc.util.BitSetUnboundedLongArray;
import java.util.Map;
import epmc.automaton.ProblemsAutomaton;
import static epmc.error.UtilError.ensure;
import epmc.expression.Expression;
import epmc.expression.standard.ExpressionOperator;
import epmc.expression.standard.ExpressionLiteral;
import epmc.operator.OperatorOr;
import epmc.operator.OperatorAnd;
import epmc.operator.OperatorNot;
import epmc.graph.explicit.GraphExplicitWrapper;
import static epmc.error.UtilError.ensure;

public class SpotParser {

  public GraphExplicitWrapper parseAutomaton(Map<String,Expression> ap2expr) {
    try {
      return Automaton(ap2expr);
    } catch (ParseException e) {
      ensure(false, ProblemsAutomaton.LTL2BA_SPOT_PROBLEM_PARSE, e, e.toString());
      return null;
    }
  }

  private Expression and(Expression a, Expression b) {
      return new ExpressionOperator.Builder()
      	.setOperator(OperatorAnd.AND)
      	.setOperands(a, b)
      	.build();
  }

    private Expression or(Expression a, Expression b) {
        return new ExpressionOperator.Builder()
            .setOperator(OperatorOr.OR)
            .setOperands(a, b)
            .build();
    }

    private Expression not(Expression expression) {
    	return new ExpressionOperator.Builder()
        	.setOperator(OperatorNot.NOT)
        	.setOperands(expression)
        	.build();
    }
}PARSER_END(SpotParser)SKIP :{  " "| "\r"| "\t"| "\n"
}TOKEN :{  < COMMA : "," >
| < COLON : ":" >
| < EQUALS : "=" >
| < NOT : "!" >
| < AND : "&" >
| < OR : "|" >
| < LPARENTH : "(" >
| < RPARENTH : ")" >
| < LBRACK : "[" >
| < RBRACK : "]" >
| < LCURLY : "{" >
| < RCURLY : "}" >
| < QUOTE : "\"" >| < ACC : "acc" >
| < HOA : "HOA" >
| < V1 : "v1" >
| < NAME : "name" >
| < TOOL : "tool" >
| < STATES : "States" >
| < START : "Start" >
| < AP : "AP" >
| < ACC_NAME : "acc-name" >
| < GENERALIZED_BUCHI : "generalized-Buchi" >
| < BUCHI : "Buchi" >
| < ALL : "all" >
| < ACCEPTANCE : "Acceptance" >
| < INF : "Inf" >
| < FIN : "Fin" >
| < PROPERTIES : "properties" >
| < BODY : "--BODY--" >
| < END : "--END--" >
| < STATE : "State" >
| < T : "t" >
| < F : "f" >
| < NUM_INT : (["1"-"9"](["0"-"9"])*)|("0") >
| < IDENTIFIER : (["a"-"z","A"-"Z","0"-"9","_","-"])+ >
// https://stackoverflow.com/questions/24156948/javacc-quote-with-escape-character
| <QUOTED: 
    "\"" 
    (
         "\\" ~[]     //any escaped character
    |                 //or
        ~["\"","\\"]  //any character except quote or backslash
    )* 
    "\"" >
}GraphExplicitWrapper Automaton(Map<String,Expression> ap2expr)  :{
  HanoiHeader header;
  GraphExplicitWrapper graph;
}{
  header = Header(ap2expr)
  graph = Body(header)
  { return graph; }
}

HanoiHeader Header(Map<String,Expression> ap2expr) :
{
  Token name;
  HanoiHeader header = new HanoiHeader(ap2expr);
  int numStates;
  int startState;
  Token ap;
  int numAccs;
  Token property;
  Token toolName;
  Token toolVersion;
  Acceptance acceptance;
  int numSets;
}
{
(  <HOA> <COLON> <V1>
| <STATES> <COLON> numStates = parseInt() { header.setNumStates(numStates); }
| <START> <COLON> startState = parseInt() { header.setStartState(startState); }
| <AP> <COLON> parseInt() ( ap = <QUOTED> { header.addAP(ap.toString()); } )*
// TODO alias
| <ACCEPTANCE> <COLON> numSets = parseInt() acceptance = Acceptance(numSets) { header.setAcceptance(acceptance); }
| <ACC_NAME> <COLON> (
    <BUCHI>  { header.setNumAcc(1); }
  | <GENERALIZED_BUCHI> numAccs = parseInt() { header.setNumAcc(numAccs); }
  | <ALL> { header.setNumAcc(0); }
)
| <TOOL> <COLON> toolName = <QUOTED> { header.setToolName(toolName.toString()); }(toolVersion = <QUOTED> { header.setToolVersion(toolVersion.toString()); })? 
| <NAME> <COLON> name = <QUOTED> { header.setName(name.toString()); }
| <PROPERTIES> <COLON> ( property = <IDENTIFIER> { header.addProperty(property.toString()); })*
)*
  { return header; }
}

Acceptance Acceptance(int numSets) :
{
  Acceptance acceptance;
}
{
  acceptance = AcceptanceOr(numSets)
  { return acceptance; }
}

Acceptance AcceptanceOr(int numSets) :
{
  Acceptance p;
  Acceptance nextProp;
}
{
  p = AcceptanceAnd(numSets)
  (
    <OR> nextProp = AcceptanceAnd(numSets)
    { p = new AcceptanceAndOr(AndOr.OR, p, nextProp); }
  )*
  { return p; }
}

Acceptance AcceptanceAnd(int numSets) :
{
  Acceptance p;
  Acceptance nextProp;
}
{
  ( p = AcceptanceSet(numSets) | p = AcceptanceBoolean(numSets) )
  (
    <AND>
    ( nextProp = AcceptanceSet(numSets) | nextProp = AcceptanceBoolean(numSets) )
    { p = new AcceptanceAndOr(AndOr.AND, p, nextProp); }
  )*
  { return p; }
}

Acceptance AcceptanceSet(int numSets) :
{
  boolean negated = false;
  InfFin infFin;
  int set;
}
{
  (<INF> { infFin = InfFin.INF; } | <FIN> { infFin = InfFin.FIN; } ) <LPARENTH> (<NOT> { negated = true; } )? set = parseInt() <RPARENTH>
  {
    ensure(set < numSets, ProblemsHoa.HOA_INVALID_ACC_SET, set, numSets);
    return new AcceptanceSet(infFin, negated, set);
  }
}

Acceptance AcceptanceBoolean(int numSets) :
{
  boolean value;
}
{
  <T> { value = true; } | <F> { value = false; }
  { return new AcceptanceBoolean(value); }
}

GraphExplicitWrapper Body(HanoiHeader header)  :
{
  GraphPreparator graph = new GraphPreparator(header);
}
{
  <BODY>
  (State(graph))*
  <END>
  { return graph.toGraph(); }
}

void State(GraphPreparator graph)  :
{
  int from;
  Expression guard;
  int to;
  BitSet acc;
  int accState;
}
{
  <STATE> <COLON> from = parseInt()
  (	<LBRACK>guard = Guard(graph.getHeader())<RBRACK> to = parseInt()
	{ acc = new BitSetUnboundedLongArray(); }
	(<LCURLY> (accState = parseInt() { acc.set(accState); })* <RCURLY>)?
	{ graph.addTransition(from, to, guard, acc); }
  )*
}

String Identifiers() :
{
  Token literal;
  String result = "";
}
{
  <QUOTE>
    (
      literal = <IDENTIFIER> { result += literal.toString(); }
      | literal = <AND> { result += literal.toString(); }
      | literal = <OR> { result += literal.toString(); }
      | literal = <NOT> { result += literal.toString(); }
      | literal = <LPARENTH> { result += literal.toString(); }
      | literal = <RPARENTH> { result += literal.toString(); }
      | literal = <NUM_INT> { result += literal.toString(); }
    )*
    <QUOTE>
  { return result; }
}

Expression Guard(HanoiHeader header) :
{
  Expression expr;
}
{
  expr = ExpressionOr(header)
  { return expr; }
}

Expression ExpressionOr(HanoiHeader header) :
{
  Expression p;
  Expression nextProp;
}
{
  p = ExpressionAnd(header)
  (
    <OR> nextProp = ExpressionAnd(header)
    { p = or(p, nextProp); }
  )*
  { return p; }
}

Expression ExpressionAnd(HanoiHeader header) :
{
  Expression p;
  Expression nextProp;
}
{
  p = ExpressionNot(header)
  (
    <AND>
    nextProp = ExpressionNot(header)
    { p = and(p, nextProp); }
  )*
  { return p; }
}

Expression ExpressionNot(HanoiHeader header) :
{
  Expression p;
}
{
  (
    <NOT>
    p = ExpressionNot(header)
    { p = not(p); }
  | <LPARENTH> p = ExpressionOr(header) <RPARENTH>
  | p = ExpressionTrue(header)
  | p = ExpressionIdentifier(header)
  )
  { return p; }
}

Expression ExpressionTrue(HanoiHeader header) :
{
  Token literal;
}
{
  <T> { return ExpressionLiteral.getTrue(); }
}

Expression ExpressionIdentifier(HanoiHeader header) :
{
  int id;
}
{
  id = parseInt()
  {
    return header.numberToIdentifier(id);
  }
}

private int parseInt() :
{
	Token intg;
}
{
	intg = <NUM_INT>
	{ return Integer.parseInt(intg.toString()); }
}
