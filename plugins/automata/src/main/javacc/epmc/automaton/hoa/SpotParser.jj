options
{
  JDK_VERSION = "1.8";
  LOOKAHEAD = 1;
  STATIC = false;
}
PARSER_BEGIN(SpotParser)package epmc.automaton.hoa;

import epmc.util.BitSet;
import epmc.util.BitSetUnboundedLongArray;
import java.util.Map;
import epmc.automaton.ProblemsAutomaton;
import static epmc.error.UtilError.ensure;
import epmc.expression.Expression;
import epmc.expression.standard.ExpressionOperator;
import epmc.expression.standard.ExpressionLiteral;
import epmc.operator.OperatorOr;
import epmc.operator.OperatorAnd;
import epmc.operator.OperatorNot;
import epmc.graph.explicit.GraphExplicitWrapper;
import static epmc.error.UtilError.ensure;

public class SpotParser {

  public GraphExplicitWrapper parseAutomaton(Map<String,Expression> ap2expr) {
    try {
      return Automaton(ap2expr);
    } catch (ParseException e) {
      ensure(false, ProblemsAutomaton.LTL2BA_SPOT_PROBLEM_PARSE, e, e.toString());
      return null;
    }
  }

  private Expression and(Expression a, Expression b) {
      return new ExpressionOperator.Builder()
      	.setOperator(OperatorAnd.AND)
      	.setOperands(a, b)
      	.build();
  }

    private Expression or(Expression a, Expression b) {
        return new ExpressionOperator.Builder()
            .setOperator(OperatorOr.OR)
            .setOperands(a, b)
            .build();
    }

    private Expression not(Expression expression) {
    	return new ExpressionOperator.Builder()
        	.setOperator(OperatorNot.NOT)
        	.setOperands(expression)
        	.build();
    }
}PARSER_END(SpotParser)SKIP :{  " "| "\r"| "\t"| "\n"
}TOKEN :{  < COMMA : "," >
| < COLON : ":" >
| < EQUALS : "=" >
| < NOT : "!" >
| < AND : "&" >
| < OR : "|" >
| < LPARENTH : "(" >
| < RPARENTH : ")" >
| < LBRACK : "[" >
| < RBRACK : "]" >
| < LCURLY : "{" >
| < RCURLY : "}" >
| < QUOTE : "\"" >| < ACC : "acc" >
| < HOA : "HOA" >
| < V1 : "v1" >
| < NAME : "name" >
| < TOOL : "tool" >
| < STATES : "States" >
| < START : "Start" >
| < AP : "AP" >
| < ACC_NAME : "acc-name" >
| < BUCHI : "Buchi" >
| < GENERALIZED_BUCHI : "generalized-Buchi" >
| < CO_BUCHI : "co-Buchi" >
| < GENERALIZED_CO_BUCHI : "generalized-co-Buchi" >
| < STREETT : "Streett" >
| < RABIN : "Rabin" >
| < GENERALIZED_RABIN : "generalized-Rabin" >
| < PARITY : "parity" >
| < ALL : "all" >
| < NONE : "none" >
| < MIN : "min" >
| < MAX : "max" >
| < ODD : "odd" >
| < EVEN : "even" >
| < ACCEPTANCE : "Acceptance" >
| < INF : "Inf" >
| < FIN : "Fin" >
| < PROPERTIES : "properties" >
| < BODY : "--BODY--" >
| < END : "--END--" >
| < STATE : "State" >
| < T : "t" >
| < F : "f" >
| < NUM_INT : (["1"-"9"](["0"-"9"])*)|("0") >
| < IDENTIFIER : (["a"-"z","A"-"Z","0"-"9","_","-"])+ >
// https://stackoverflow.com/questions/24156948/javacc-quote-with-escape-character
| <QUOTED: 
    "\"" 
    (
         "\\" ~[]     //any escaped character
    |                 //or
        ~["\"","\\"]  //any character except quote or backslash
    )* 
    "\"" >
}GraphExplicitWrapper Automaton(Map<String,Expression> ap2expr)  :{
  HanoiHeader header;
  GraphExplicitWrapper graph;
}{
  header = Header(ap2expr)
  graph = Body(header)
  { return graph; }
}

HanoiHeader Header(Map<String,Expression> ap2expr) :
{
  HanoiHeader header = new HanoiHeader(ap2expr);
  boolean statesSpecified = false;
  boolean apSpecified = false;
  boolean acceptanceSpecified = false;
  boolean accNameSpecified = false;
  boolean toolSpecified = false;
  boolean nameSpecified = false;
}
{
  <HOA> <COLON> <V1>
(
  ( { ensure(!statesSpecified, ProblemsHoa.HOA_MULTIPLE_ITEMS_STATES); statesSpecified = true; } States(header) )
| Start(header)
| ( { ensure(!apSpecified, ProblemsHoa.HOA_MULTIPLE_ITEMS_AP); apSpecified = true; } AP(header) )// TODO alias
| ( { ensure(!acceptanceSpecified, ProblemsHoa.HOA_MULTIPLE_ITEMS_ACCEPTANCE); acceptanceSpecified = true; } Acceptance(header))
| ( { ensure(!accNameSpecified, ProblemsHoa.HOA_MULTIPLE_ITEMS_ACCEPTANCE); accNameSpecified = true; } AccName(header) )
| ( { ensure(!toolSpecified, ProblemsHoa.HOA_MULTIPLE_ITEMS_TOOL); toolSpecified = true; } Tool(header) )
| ( { ensure(!nameSpecified, ProblemsHoa.HOA_MULTIPLE_ITEMS_NAME); nameSpecified = true; } Name(header) )
| Properties(header)
)*
  {
    ensure(acceptanceSpecified, ProblemsHoa.HOA_MISSING_ITEM_ACCEPTANCE);
    BitSet startStates = header.getStartStates();
    for (int state = startStates.nextSetBit(0); state >= 0; state = startStates.nextSetBit(state + 1)) {
      ensure(state < header.getNumStates(), ProblemsHoa.HOA_INVALID_START_STATE, state, header.getNumStates());
    }
    return header;
  }
}

void States(HanoiHeader header) :
{
  int numStates;
}
{
  <STATES> <COLON> numStates = parseInt() { header.setNumStates(numStates); }
}

void Start(HanoiHeader header) :
{
  int startState;
}
{
 <START> <COLON> startState = parseInt() { header.setStartState(startState); }
}

void AP(HanoiHeader header) :
{
  Token ap;
  int numAPs;
  int numAPsAdded = 0;
}
{
 <AP> <COLON> numAPs = parseInt() { header.setNumAPs(numAPs); } ( ap = <QUOTED>
  {
    ensure(numAPsAdded < numAPs, ProblemsHoa.HOA_TOO_MANY_APS, numAPs, ap);
    numAPsAdded++;
    header.addAP(ap.toString());
  } )*
}

void Acceptance(HanoiHeader header) :
{
  int numSets;
  Acceptance acceptance;
}
{
 <ACCEPTANCE> <COLON> numSets = parseInt() { header.setNumAccSets(numSets); } acceptance = AcceptanceOr(numSets) { header.setAcceptance(acceptance); }
 { header.setAcceptance(acceptance); }
}

Acceptance AcceptanceOr(int numSets) :
{
  Acceptance p;
  Acceptance nextProp;
}
{
  p = AcceptanceAnd(numSets)
  (
    <OR> nextProp = AcceptanceAnd(numSets)
    { p = new AcceptanceAndOr(AndOr.OR, p, nextProp); }
  )*
  { return p; }
}

Acceptance AcceptanceAnd(int numSets) :
{
  Acceptance p;
  Acceptance nextProp;
}
{
  ( p = AcceptanceSet(numSets) | p = AcceptanceBoolean(numSets) )
  (
    <AND>
    ( nextProp = AcceptanceSet(numSets) | nextProp = AcceptanceBoolean(numSets) )
    { p = new AcceptanceAndOr(AndOr.AND, p, nextProp); }
  )*
  { return p; }
}

Acceptance AcceptanceSet(int numSets) :
{
  boolean negated = false;
  InfFin infFin;
  int set;
}
{
  (<INF> { infFin = InfFin.INF; } | <FIN> { infFin = InfFin.FIN; } ) <LPARENTH> (<NOT> { negated = true; } )? set = parseInt() <RPARENTH>
  {
    ensure(set < numSets, ProblemsHoa.HOA_INVALID_ACC_SET, set, numSets);
    return new AcceptanceSet(infFin, negated, set);
  }
}

Acceptance AcceptanceBoolean(int numSets) :
{
  boolean value;
}
{
  <T> { value = true; } | <F> { value = false; }
  { return new AcceptanceBoolean(value); }
}

void AccName(HanoiHeader header) :
{
  int numAccs;
  int numPairs;
  int numParsedPairs = 0;
  int genParameter;
  AcceptanceName name = new AcceptanceName();
  String minMax;
  String oddEven;
  Token identifier;
  int intParameter;
}
{
  <ACC_NAME> <COLON> (
    (<BUCHI> { name.setName("Buchi"); })
  | (<GENERALIZED_BUCHI> numAccs = parseInt() { name.setName("generalized-Buchi"); name.addParameter(numAccs); })
  | (<CO_BUCHI> { name.setName("co-Buchi"); })
  | (<GENERALIZED_CO_BUCHI> numAccs = parseInt() { name.setName("generalized-co-Buchi"); name.addParameter(numAccs); })
  | (<STREETT> numAccs = parseInt() { name.setName("Streett"); name.addParameter(numAccs); })
  | (<RABIN> numAccs = parseInt() { name.setName("Rabin"); name.addParameter(numAccs); })
  | (<GENERALIZED_RABIN> numPairs = parseInt() { name.setName("generalized-Rabin"); name.addParameter(numPairs); } (genParameter = parseInt() {name.addParameter(genParameter);})*)
  | (<PARITY> numPairs = parseInt() (<MIN> {minMax = "min";} | <MAX> {minMax = "max";} ) (<ODD> {oddEven = "odd";} | <EVEN> {oddEven = "even";} ) numPairs = parseInt() { name.setName("Parity"); name.addParameter(minMax); name.addParameter(oddEven); name.addParameter(numPairs); } )
  | (<ALL> { name.setName("all"); })
  | (<NONE> { name.setName("none"); })
  | (identifier = <IDENTIFIER> { name.setName(identifier.toString()); } ( (identifier = <IDENTIFIER> { name.addParameter(identifier.toString()); } ) | (intParameter = parseInt() { name.addParameter(intParameter); }) )* )
 )
 {
   header.setAcceptanceName(name);
 }
}

void Tool(HanoiHeader header) :
{
  Token toolName;
  Token toolVersion;
}
{
 <TOOL> <COLON> toolName = <QUOTED> { header.setToolName(toolName.toString()); }(toolVersion = <QUOTED> { header.setToolVersion(toolVersion.toString()); })? 
}

void Name(HanoiHeader header) :
{
  Token name;
}
{
 <NAME> <COLON> name = <QUOTED> { header.setName(name.toString()); }
}

void Properties(HanoiHeader header) :
{
  Token property;
}
{
 <PROPERTIES> <COLON> ( property = <IDENTIFIER> { header.addProperty(property.toString()); })*
}

GraphExplicitWrapper Body(HanoiHeader header)  :
{
  GraphPreparator graph = new GraphPreparator(header);
}
{
  <BODY>
  (State(header, graph))*
  <END>
  { return graph.toGraph(); }
}

void State(HanoiHeader header, GraphPreparator graph)  :
{
  int from;
  Expression guard;
  int to;
  BitSet acc;
}
{
  <STATE> <COLON> from = parseInt()
  {
      ensure(from < header.getNumStates(), ProblemsHoa.HOA_INVALID_FROM_STATE,
          from, header.getNumStates());
  }
  (	<LBRACK>guard = Guard(graph.getHeader())<RBRACK>
	to = parseInt()
    {
        ensure(to < header.getNumStates(), ProblemsHoa.HOA_INVALID_TO_STATE,
            to, header.getNumStates());
    }
    acc = AcceptanceSets(header)
	{ graph.addTransition(from, to, guard, acc); }
  )*
}

BitSet AcceptanceSets(HanoiHeader header) :
{
  BitSet acc;
  int accState;
}
{
  { acc = new BitSetUnboundedLongArray(); }
  (<LCURLY> (accState = parseInt()
    { ensure(accState < header.getNumAcc(), ProblemsHoa.HOA_INVALID_ACC_NUMBER,
        accState, header.getNumAcc());
      acc.set(accState); }
    )* <RCURLY>)?
  { return acc; }
}

String Identifiers() :
{
  Token literal;
  String result = "";
}
{
  <QUOTE>
    (
      literal = <IDENTIFIER> { result += literal.toString(); }
      | literal = <AND> { result += literal.toString(); }
      | literal = <OR> { result += literal.toString(); }
      | literal = <NOT> { result += literal.toString(); }
      | literal = <LPARENTH> { result += literal.toString(); }
      | literal = <RPARENTH> { result += literal.toString(); }
      | literal = <NUM_INT> { result += literal.toString(); }
    )*
    <QUOTE>
  { return result; }
}

Expression Guard(HanoiHeader header) :
{
  Expression expr;
}
{
  expr = ExpressionOr(header)
  { return expr; }
}

Expression ExpressionOr(HanoiHeader header) :
{
  Expression p;
  Expression nextProp;
}
{
  p = ExpressionAnd(header)
  (
    <OR> nextProp = ExpressionAnd(header)
    { p = or(p, nextProp); }
  )*
  { return p; }
}

Expression ExpressionAnd(HanoiHeader header) :
{
  Expression p;
  Expression nextProp;
}
{
  p = ExpressionNot(header)
  (
    <AND>
    nextProp = ExpressionNot(header)
    { p = and(p, nextProp); }
  )*
  { return p; }
}

Expression ExpressionNot(HanoiHeader header) :
{
  Expression p;
}
{
  (
    <NOT>
    p = ExpressionNot(header)
    { p = not(p); }
  | <LPARENTH> p = ExpressionOr(header) <RPARENTH>
  | p = ExpressionTrue(header)
  | p = ExpressionFalse(header)
  | p = ExpressionIdentifier(header)
  )
  { return p; }
}

Expression ExpressionTrue(HanoiHeader header) :
{
}
{
  <T> { return ExpressionLiteral.getTrue(); }
}

Expression ExpressionFalse(HanoiHeader header) :
{
}
{
  <F> { return ExpressionLiteral.getFalse(); }
}

Expression ExpressionIdentifier(HanoiHeader header) :
{
  int id;
}
{
  id = parseInt()
  { ensure(id < header.getNumAPs(), ProblemsHoa.HOA_INVALID_AP_NUMBER);
    return header.numberToIdentifier(id);
  }
}

private int parseInt() :
{
	Token intg;
}
{
	intg = <NUM_INT>
	{ return Integer.parseInt(intg.toString()); }
}
