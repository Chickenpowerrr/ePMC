options
{
  JDK_VERSION = "1.8";
  LOOKAHEAD = 1;
  STATIC = false;
}

PARSER_BEGIN(GuardedCommandExpressionParser)
package epmc.guardedcommand.expression;
import epmc.error.UtilError;
import epmc.guardedcommand.error.ProblemsGuardedCommand;
import epmc.error.Positional;
import static epmc.error.UtilError.ensure;
import epmc.error.EPMCException;
import epmc.value.Operator;
import epmc.value.Value;
import epmc.value.ContextValue;
import epmc.value.OperatorAnd;
import epmc.value.OperatorNot;
import epmc.value.OperatorAddInverse;
import epmc.value.OperatorImplies;
import epmc.value.OperatorIff;
import epmc.value.OperatorOr;
import epmc.value.OperatorIte;
import epmc.value.OperatorEq;
import epmc.value.OperatorNe;
import epmc.value.OperatorAdd;
import epmc.value.OperatorSubtract;
import epmc.value.OperatorLe;
import epmc.value.OperatorLt;
import epmc.value.OperatorGe;
import epmc.value.OperatorGt;
import epmc.value.OperatorMultiply;
import epmc.value.OperatorDivide;
import epmc.value.OperatorPow;
import epmc.value.OperatorMax;
import epmc.value.OperatorMin;
import epmc.value.OperatorCeil;
import epmc.value.OperatorFloor;
import epmc.value.OperatorLog;
import epmc.value.OperatorMod;
import epmc.value.ValueInteger;
import epmc.value.TypeInteger;
import epmc.value.TypeReal;
import epmc.value.UtilValue;
import epmc.value.ValueAlgebra;
import epmc.expression.*;
import epmc.expression.standard.ExpressionIdentifierStandard;
import epmc.expression.standard.ExpressionFilter;
import epmc.expression.standard.ExpressionMultiObjective;
import epmc.expression.standard.ExpressionCoalition;
import epmc.expression.standard.ExpressionTemporal;
import epmc.expression.standard.ExpressionReward;
import epmc.expression.standard.ExpressionQuantifier;
import epmc.expression.standard.ExpressionSteadyState;
import epmc.expression.standard.ExpressionLiteral;
import epmc.expression.standard.ExpressionOperator;
import epmc.expression.standard.TemporalType;
import epmc.expression.standard.FilterType;
import epmc.expression.standard.TimeBound;
import epmc.expression.standard.RewardType;
import epmc.expression.standard.CmpType;
import epmc.expression.standard.DirType;

import java.util.ArrayList;
import java.util.List;

public final class GuardedCommandExpressionParser {
	private ContextValue contextVal;
	private int initialLine;
	private int initialColumn;
	private int errorLine;
	private int errorColumn;

	private void computeErrorPosition(int tline, int tcolumn) {
		errorLine = tline + initialLine - 1;
		errorColumn = tcolumn;
		if (tline == 1) {
			errorColumn += initialColumn - 1;
		}
	}

	public Expression parseExpression(ContextValue contextVal) throws EPMCException {
		return parseExpression(contextVal, 1, 1);
	}

	public Expression parseExpression(ContextValue contextVal, int line, int column) throws EPMCException {
		this.contextVal = contextVal;
		this.initialLine = line;
		this.initialColumn = column;

		try {
			return parseCompleteExp();
		} catch (ParseException pe) {
			Token errorToken = getToken(1);
			if (errorToken.kind == UNEXPECTED_CHAR) {
				computeErrorPosition(errorToken.endLine, errorToken.endColumn);
				ensure(false, ProblemsGuardedCommand.GUARDEDCOMMAND_EXPRESSION_PARSER_UNEXPECTED_CHARACTER, newPositional(errorLine, errorColumn), errorToken.image);
			} else {
				computeErrorPosition(errorToken.beginLine, errorToken.beginColumn);
				ensure(false, ProblemsGuardedCommand.GUARDEDCOMMAND_EXPRESSION_PARSER_SYNTAX_ERROR, newPositional(errorLine, errorColumn), errorToken.toString());
			}
			return null;
        } catch (EPMCException e) {
		   throw e;
		}
		catch (Throwable t) {
		  ensure(false, ProblemsGuardedCommand.GUARDEDCOMMAND_EXPRESSION_PARSER_GENERAL_ERROR, t, t);
		  return null;
		}
	}

	private ExpressionOperator newOperator(Operator operator, Expression... operands) {
	  return new ExpressionOperator.Builder()
	  	.setOperator(operator)
	  	.setOperands(operands)
	  	.build();
	}

	private ExpressionOperator newOperator(String operator, Expression... operands) {
	  return new ExpressionOperator.Builder()
	  	.setOperator(contextVal.getOperator(operator))
	  	.setOperands(operands)
	  	.build();
	}

  private Expression and(Expression a, Expression b) {
      return newOperator(OperatorAnd.IDENTIFIER, a, b);
  }

    private Expression not(Expression expression) {
    	return new ExpressionOperator.Builder()
        	.setOperator(contextVal.getOperator(OperatorNot.IDENTIFIER))
        	.setOperands(expression)
        	.build();
    }

  private Expression addInverse(Expression expression) {
    return new ExpressionOperator.Builder()
      	.setOperator(contextVal.getOperator(OperatorAddInverse.IDENTIFIER))
      	.setOperands(expression)
      	.build();
  }

    private Expression or(Expression a, Expression b) {
        return new ExpressionOperator.Builder()
            .setOperator(contextVal.getOperator(OperatorOr.IDENTIFIER))
            .setOperands(a, b)
            .build();
    }

    private Expression iff(Expression a, Expression b) {
        return new ExpressionOperator.Builder()
            .setOperator(contextVal.getOperator(OperatorIff.IDENTIFIER))
            .setOperands(a, b)
            .build();
    }

    private Expression implies(Expression a, Expression b) {
        return new ExpressionOperator.Builder()
            .setOperator(contextVal.getOperator(OperatorImplies.IDENTIFIER))
            .setOperands(a, b)
            .build();
    }

    private static boolean isPosInf(Expression expression) {
        assert expression != null;
        if (!(expression instanceof ExpressionLiteral)) {
            return false;
        }
        ExpressionLiteral expressionLiteral = (ExpressionLiteral) expression;
        return ValueAlgebra.asAlgebra(expressionLiteral.getValue()).isPosInf();
    }

    private ValueInteger newValueInteger(String string) throws EPMCException {
      assert string != null;
      return UtilValue.newValue(TypeInteger.get(contextVal), string);
  }

    private static Positional newPositional(long line, long column) {
        assert line >= 0;
        assert column >= 0;
        return new Positional.Builder()
                .setLine(line)
                .setColumn(column)
                .build();
    }
}

PARSER_END(GuardedCommandExpressionParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : // RESERVED KEYWORDS
{
	< A : "A" >
|	< BOOL : "bool" >
|	< CEIL : "ceil" >
|	< CONSTANT : "const" >
|	< C : "C" >
|	< DISCOUNT : "DISCOUNT" >
|	< DOUBLE : "double" >
|	< E : "E" >
|	< FALSE : "false" >
|	< FORMULA : "formula" >
|	< FILTER : "filter" >
|	< FLOOR : "floor" >
|	< FUNCTION : "func" >
|	< F : "F" >
|	< G : "G" >
|	< INIT : "init" >
|	< INITEND : "endinit" >
|	< INVARIANT_OPEN : "invariant" >
|	< INVARIANT_CLOSE : "endinvariant" >
|	< I : "I" >
|	< INT : "int" >
|	< LABEL : "label" >
|	< LOG : "log" >
|	< MAX : "max" >
|	< MIN : "min" >
|	< MOD : "mod" >
|	< MODULEBEGIN : "module" >
|	< MODULEEND : "endmodule" >
|	< POW : "pow" >
|	< R : "R">
|	< REWARDSBEGIN : "rewards" >
|	< REWARDSEND : "endrewards" >
|	< RMAX : "Rmax">
|	< RMIN : "Rmin">
|	< SQRT : "sqrt" >
|	< SYSTEMBEGIN : "system" >
|	< SYSTEMEND : "endsystem" >
|	< TRUE : "true" >
|	< U : "U" >
|	< W : "W" >
|	< X : "X" >
|	< COND : "given" >
|	< PLUS : "+" >
|	< MINUS : "-" >
|	< TIMES : "*" >
|	< DIVIDE : "/" >
|	< ARROW : "->" >
|	< LBRACKET : "[" >
|	< RBRACKET : "]" >
|	< LPAR : "(" >
|	< RPAR : ")" >
|	< LCURL : "{" >
|	< RCURL : "}" >
|	< RENAME : "<-" >
|	< SEMICOLON : ";" >
|	< COLON : ":" >
|	< COMMA : "," >
|	< AND : "&" >
|	< OR : "|" >
|	< NOT : "!" >
|	< IMPLIES : "=>" >
|	< IFF : "<=>" >
|	< QUESTION : "?" >
|	< PRIME : "'" >
|	< EQ : "=" >
|	< NEQ : "!=" >
|	< LEQ : "<=" >
|	< LT : "<" >
|	< GT : ">" >
|	< GEQ : ">=" >
|	< QUOTE : "\"" >
|	< SEPINTERVAL : ".." >
// game stuff
|	< SMG : "smg" >
|	< COALITION_OPEN : "<<" >
|	< COALITION_CLOSE : ">>" >
|	< PLAYERBEGIN : "player" >
|	< PLAYEREND : "endplayer" >
|	< IDENTIFIER : [ "A"-"Z","a"-"z","_" ] ( [ "A"-"Z","a"-"z","_","0"-"9" ] )* >
|	< NUM_INT : (["1"-"9"](["0"-"9"])*)|("0") >
|	< NUM_REAL : (["0"-"9"])+(".")?(["0"-"9"])+(["e","E"](["-","+"])?(["0"-"9"])+)? >
}

SPECIAL_TOKEN :
{
//	< COMMENT : "//"(~["\n","\r"])*("\n"|"\r"|"\r\n") >
	< COMMENT : "//"(~["\n","\r"])* >
}

TOKEN :
{
	< UNEXPECTED_CHAR : ~[] >
}

private Expression parseCompleteExp() throws EPMCException :
{
	Expression e;
}
{
	e = parseExp()
	<EOF>
	{ return e; }
}

private Expression parseExp() throws EPMCException :
{
	Expression e;
}
{
	e = ExpressionITE()
	{ return e; }
}

private Expression ExpressionITE() throws EPMCException :
{
	Expression prop;
	Expression propThen;
	Expression propElse;
}
{
	prop = ExpressionImplies()
	(
		<QUESTION>
		propThen = ExpressionImplies()
		<COLON>
		propElse = ExpressionITE()
		{ prop = new ExpressionOperator.Builder()
			.setOperator(contextVal.getOperator(OperatorIte.IDENTIFIER))
			.setOperands(prop, propThen, propElse)
			.build(); }
	)?
	{ return prop; }
}

private Expression ExpressionImplies() throws EPMCException :
{
	Expression p;
	Expression nextProp;
}
{
	p = ExpressionIff()
	(
		<IMPLIES> 
		nextProp = ExpressionIff()
		{ p = implies(p, nextProp); }
	)*
	{ return p; }
}

private Expression ExpressionIff() throws EPMCException :
{
	Expression p;
	Expression nextProp;
}
{
	p = ExpressionOr()
	(
		<IFF> 
		nextProp = ExpressionOr()
		{ p = iff(p, nextProp); }
	)*
	{ return p; }
}

private Expression ExpressionOr() throws EPMCException :
{
	Expression p;
	Expression nextProp;
}
{
	p = ExpressionAnd()
	(
		<OR> 
		nextProp = ExpressionAnd()
		{ p = or(p, nextProp); }
	)*
	{ return p; }
}

private Expression ExpressionAnd() throws EPMCException :
{
	Expression p;
	Expression nextProp;
}
{
	p = ExpressionNot()
	(
		<AND>
		nextProp = ExpressionNot()
		{ p = and(p, nextProp); }
	)*
	{ return p; }
}

private Expression ExpressionNot() throws EPMCException :
{
	  Expression p;
}
{
	(
		<NOT>
		p = ExpressionNot()
		{ p = not(p); }
	| 
		p = ExpressionEqNe()
	)
	{ return p; }
}

private Expression ExpressionEqNe() throws EPMCException :
{
	Expression p;
	Expression nextProp;
	Operator type;
}
{
	p = ExpressionROp()
	(
		type = EqNe() 
		nextProp = ExpressionROp()
		{ p = newOperator(type, p, nextProp); }
	)*
	{ return p; }
}

private Operator EqNe() throws EPMCException :
{
}
{
	(
		<EQ> 
		{ return contextVal.getOperator(OperatorEq.IDENTIFIER); }
	| 
		<NEQ> 
		{ return contextVal.getOperator(OperatorNe.IDENTIFIER); }
	)
}

private Expression ExpressionROp() throws EPMCException :
{
	Expression p;
	Expression nextProp;
	Operator type;
}
{
	p = ExpressionPlusMinus()
	(
		type = LtGtLeGe()
		nextProp = ExpressionPlusMinus()
		{ p = newOperator(type, p, nextProp); }
	)*
	{ return p; }
}

private Operator LtGtLeGe() throws EPMCException :
{
}
{
	(
		<LT> 
		{ return contextVal.getOperator(OperatorLt.IDENTIFIER); }
	| 
		<LEQ> 
		{ return contextVal.getOperator(OperatorLe.IDENTIFIER); }
	| 
		<GT> 
		{ return contextVal.getOperator(OperatorGt.IDENTIFIER); }
	| 
		<GEQ> 
		{ return contextVal.getOperator(OperatorGe.IDENTIFIER); }
	)
}

private Expression ExpressionPlusMinus() throws EPMCException :
{
	Expression p;
	Expression nextProp;
	Operator type;
}
{
	p = ExpressionTimesDivide()
	(
		LOOKAHEAD((<PLUS>|<MINUS>))
		type = PlusMinus()
		nextProp = ExpressionTimesDivide()
		{ p = newOperator(type, p, nextProp); }
	)*
	{ return p; }
}

private Operator PlusMinus() throws EPMCException :
{
}
{
	(
		<PLUS> 
		{ return contextVal.getOperator(OperatorAdd.IDENTIFIER); }
	| 
		<MINUS> 
		{ return contextVal.getOperator(OperatorSubtract.IDENTIFIER); }
	)
}

private Expression ExpressionTimesDivide() throws EPMCException :
{
	Expression p;
	Expression nextProp;
	Operator type;
}
{
	p = ExpressionUnaryMinus()
	(
		type = TimesDivide()
		nextProp = ExpressionUnaryMinus()
		{ p = newOperator(type, p, nextProp); }
	)*
	{ return p; }
}

private Operator TimesDivide() throws EPMCException :
{
}
{
	(
		<TIMES> 
		{ return contextVal.getOperator(OperatorMultiply.IDENTIFIER); }
	| 
		<DIVIDE> 
		{ return contextVal.getOperator(OperatorDivide.IDENTIFIER); }
	)
}

private Expression ExpressionUnaryMinus() throws EPMCException :
{
	  Expression p;
}
{
	(
		<MINUS> 
		p = ExpressionUnaryMinus()
		{ p = addInverse(p); }
	| 
		p = parseBasic()
	)
	{ return p; }
}

private Expression parseBasic() throws EPMCException :
{
	Expression e;
}
{
	(
		e = parseBoolean()
	|
		e = parseFunction()
	|
		e = parseIdentifier()
	|
		e = parseInt()
	|
		e = parseReal()
	| 
		e = parseParenth()
	| 
		e = parseLabel()
	)
	{ return e; }
}

private Expression parseFunction() throws EPMCException :
{
	Expression e;
	Expression ne;
	Operator type;
}
{
	(
		e = parseSpecialFunction()
	|
		type = functionMultipleParams()
		<LPAR>
		e = parseFunctionN(type)
		<RPAR>
	|
		type = functionTwoParams()
		<LPAR>
		e = parseFunction2(type)
		<RPAR>
	|
		type = functionOneParam()
		<LPAR>
		e = parseFunction1(type)
		<RPAR>
	|
		<FUNCTION> 
		<LPAR>
		(
			e = parseSqrt()
		|
			type = functionMultipleParams()
			<COMMA>
			e = parseFunctionN(type)
		|
			type = functionTwoParams()
			<COMMA>
			e = parseFunction2(type)
		|
			type = functionOneParam()
			<COMMA>
			e = parseFunction1(type)
		)
		<RPAR>
	)
	{ return e; }
}

private Expression parseSpecialFunction() throws EPMCException :
{
	Expression e;
}
{
	(
		e = parseSqrt()
	)
	{ return e; }
}

private Expression parseSqrt() throws EPMCException :
{
	Expression e;
}
{
	//sqrt(e) is just pow(e, 0.5), but it has to be managed independently...
	<SQRT>
	<LPAR>
	e = parseExp()
	<RPAR>
	{ return newOperator(contextVal.getOperator(OperatorPow.IDENTIFIER), e,
		new ExpressionLiteral.Builder()
			.setValue(UtilValue.newValue(TypeReal.get(contextVal), "0.5"))
			.build()); }
}

private Expression parseFunctionN(Operator type) throws EPMCException :
{
	Expression e;
	Expression ne;
}
{
	e = parseExp()
	(
		<COMMA>
		ne = parseExp()
		{ e = newOperator(type, e, ne);}
	)+
	{ return e; }
}

private Expression parseFunction2(Operator type) throws EPMCException :
{
	Expression e;
	Expression ne;
}
{
	e = parseExp()
	<COMMA>
	ne = parseExp()
	{ return newOperator(type, e, ne);}
}

private Expression parseFunction1(Operator type) throws EPMCException :
{
	Expression e;
}
{
	e = parseExp()
	{ return newOperator(type, e);}
}

private Operator functionMultipleParams() throws EPMCException :
{
}
{
	(
		<MAX> 
		{ return contextVal.getOperator(OperatorMax.IDENTIFIER); }
	| 
		<MIN> 
		{ return contextVal.getOperator(OperatorMin.IDENTIFIER); }
	)
}

private Operator functionOneParam() throws EPMCException :
{
}
{
	(
//		//sqrt(e) is just pow(e, 0.5), but it has to be managed independently...
//		<SQRT> 
//	|
		<FLOOR> 
		{ return contextVal.getOperator(OperatorFloor.IDENTIFIER); }
	| 
		<CEIL> 
		{ return contextVal.getOperator(OperatorCeil.IDENTIFIER); }
	)
}

private Operator functionTwoParams() throws EPMCException :
{
}
{
	(
		<POW> 
		{ return contextVal.getOperator(OperatorPow.IDENTIFIER); }
	| 
		<MOD> 
		{ return contextVal.getOperator(OperatorMod.IDENTIFIER); }
	| 
		<LOG> 
		{ return contextVal.getOperator(OperatorLog.IDENTIFIER); }
	)
}

private Expression parseParenth() throws EPMCException :
{
	Expression p;
}
{
	<LPAR>
	p = parseExp()
	<RPAR>
	{ return p; }
}

private Expression parseIdentifier() throws EPMCException :
{
	Token literal;
}
{
	literal = <IDENTIFIER>
	{ return new ExpressionIdentifierStandard.Builder()
		.setName(literal.toString())
		.build(); }
}

private Expression parseLabel() throws EPMCException :
{
	Token literal;
}
{
	<QUOTE> 
	(
		literal = <IDENTIFIER> 
	|
		literal = <INIT>
	)
	<QUOTE>
	{ return new ExpressionIdentifierStandard.Builder()
		.setName("\"" + literal.toString() + "\"")
		.build(); }
}

private Expression parseReal() throws EPMCException :
{
	Token real;
}
{
	real = <NUM_REAL>
	{ return new ExpressionLiteral.Builder()
		.setValue(UtilValue.newValue(TypeReal.get(contextVal), real.toString()))
		.build(); }
}

private Expression parseInt() throws EPMCException :
{
	Token intg;
}
{
	intg = <NUM_INT>
	{ return new ExpressionLiteral.Builder()
		.setValue(newValueInteger(intg.toString()))
		.build(); }
}

private List<Expression> parseList() throws EPMCException : 
{
	List<Expression> vector = new ArrayList<Expression>();
	Expression element;
}
{
	element = parseExp()
	{ vector.add(element); }
	(
		<COMMA>
		element = parseExp()
		{ vector.add(element); }
	)*
	{ return vector; }
}

private Expression parseBoolean() throws EPMCException :
{
}
{
	(
		<TRUE> 
		{ return ExpressionLiteral.getTrue(contextVal); } 
	|
		<FALSE> 
		{ return ExpressionLiteral.getFalse(contextVal); }
	)
}

